import * as r from "react";
import { useRef as oe, useMemo as Ie, useCallback as Z, useEffect as Ne } from "react";
import { u as x, r as _e, a as we, b as Fe, c as Q, d as xe, e as Ue, f as re, g as He, h as Ve, i as ie, j as qe, k as Be, m as je, G as ze, n as We, o as Ge, p as ue, q as Je, t as $e, v as Pe, w as de, x as Le, y as Qe, l as V, z as Ke, A as Ye, B as le, C as Xe, D as Ze, E as et, F as tt, H as nt, I as st, J as rt, K as ot, M as ge, N as at, O as ct, P as it, Q as ut, S as dt, T as lt, U as ft, V as mt, W as Ae, X as pt, Y as ht, Z as bt, _ as gt, $ as vt, a0 as St, a1 as yt, a2 as Ct, a3 as Mt, a4 as Et, a5 as Tt, a6 as kt, a7 as ce, a8 as G, a9 as wt, aa as Pt, ab as Lt, ac as At, ad as Rt } from "./contexts-CjCD4TaH.mjs";
import { m as J } from "./room-BH8Rm3Ha.mjs";
import { ConnectionState as O, LocalTrackPublication as Dt, facingModeFromLocalTrack as Ot, Room as Re, Track as w, createAudioAnalyser as fe, ParticipantKind as ne, Mutex as It, ParticipantEvent as Y, RoomEvent as H, decodeTokenPayload as Nt, TokenSourceConfigurable as _t } from "livekit-client";
const Ft = (e) => {
  const n = r.useRef(e);
  return r.useEffect(() => {
    n.current = e;
  }), n;
};
function xt(e, n) {
  const t = Ht(), s = Ft(n);
  return r.useLayoutEffect(() => {
    let o = !1;
    const c = e.current;
    if (!c) return;
    function a(i, d) {
      o || s.current(i, d);
    }
    return t == null || t.subscribe(c, a), () => {
      o = !0, t == null || t.unsubscribe(c, a);
    };
  }, [e.current, t, s]), t == null ? void 0 : t.observer;
}
function Ut() {
  let e = !1, n = [];
  const t = /* @__PURE__ */ new Map();
  if (typeof window > "u")
    return;
  const s = new ResizeObserver((o, c) => {
    n = n.concat(o), e || window.requestAnimationFrame(() => {
      const a = /* @__PURE__ */ new Set();
      for (let i = 0; i < n.length; i++) {
        if (a.has(n[i].target)) continue;
        a.add(n[i].target);
        const d = t.get(n[i].target);
        d == null || d.forEach((l) => l(n[i], c));
      }
      n = [], e = !1;
    }), e = !0;
  });
  return {
    observer: s,
    subscribe(o, c) {
      s.observe(o);
      const a = t.get(o) ?? [];
      a.push(c), t.set(o, a);
    },
    unsubscribe(o, c) {
      const a = t.get(o) ?? [];
      if (a.length === 1) {
        s.unobserve(o), t.delete(o);
        return;
      }
      const i = a.indexOf(c);
      i !== -1 && a.splice(i, 1), t.set(o, a);
    }
  };
}
let ae;
const Ht = () => ae || (ae = Ut()), Vt = (e) => {
  const [n, t] = r.useState({ width: 0, height: 0 });
  r.useLayoutEffect(() => {
    if (e.current) {
      const { width: o, height: c } = e.current.getBoundingClientRect();
      t({ width: o, height: c });
    }
  }, [e.current]);
  const s = r.useCallback(
    (o) => t(o.contentRect),
    []
  );
  return xt(e, s), n;
};
function A(e, n, t = !0) {
  const [s, o] = r.useState(n);
  return r.useEffect(() => {
    if (t && o(n), typeof window > "u" || !e) return;
    const c = e.subscribe(o);
    return () => c.unsubscribe();
  }, [e, t]), s;
}
function Tn(e) {
  const n = (c) => typeof window < "u" ? window.matchMedia(c).matches : !1, [t, s] = r.useState(n(e));
  function o() {
    s(n(e));
  }
  return r.useEffect(() => {
    const c = window.matchMedia(e);
    return o(), c.addListener ? c.addListener(o) : c.addEventListener("change", o), () => {
      c.removeListener ? c.removeListener(o) : c.removeEventListener("change", o);
    };
  }, [e]), t;
}
function kn(e) {
  const n = x(e), t = r.useCallback(async () => {
    await n.startAudio();
  }, [n]), s = r.useMemo(
    () => _e(n),
    [n]
  ), { canPlayAudio: o } = A(s, {
    canPlayAudio: n.canPlaybackAudio
  });
  return { canPlayAudio: o, startAudio: t };
}
function wn(e) {
  const { state: n, dispatch: t } = we().pin;
  return { buttonProps: r.useMemo(() => {
    const { className: o } = Fe();
    return J(e, {
      className: o,
      disabled: !(n != null && n.length),
      onClick: () => {
        t && t({ msg: "clear_pin" });
      }
    });
  }, [e, t, n]) };
}
function Pn(e = {}) {
  const n = Q(e.participant), { className: t, connectionQualityObserver: s } = r.useMemo(
    () => xe(n),
    [n]
  ), o = A(s, n.connectionQuality);
  return { className: t, quality: o };
}
function ee(e) {
  const n = x(e), t = r.useMemo(() => Ue(n), [n]);
  return A(t, n.state);
}
function Ln(e, n) {
  const t = typeof e == "function" ? e : n, s = typeof e == "string" ? e : void 0, o = re(), { send: c, messageObservable: a, isSendingObservable: i } = r.useMemo(
    () => He(o, s, t),
    [o, s, t]
  ), d = A(a, void 0), l = A(i, !1);
  return {
    message: d,
    send: c,
    isSending: l
  };
}
function An(e) {
  const n = re(), t = ee(n);
  return { buttonProps: r.useMemo(() => {
    const { className: o, disconnect: c } = Ve(n);
    return J(e, {
      className: o,
      onClick: () => c(e.stopTracks ?? !0),
      disabled: t === O.Disconnected
    });
  }, [n, e, t]) };
}
function qt(e) {
  if (e.publication instanceof Dt) {
    const n = e.publication.track;
    if (n) {
      const { facingMode: t } = Ot(n);
      return t;
    }
  }
  return "undefined";
}
function Rn({ trackRef: e, props: n }) {
  const t = ie(e), s = qe(), { className: o } = r.useMemo(() => Be(), []), c = r.useMemo(() => je(t, s == null ? void 0 : s.pin.state), [t, s == null ? void 0 : s.pin.state]);
  return { mergedProps: r.useMemo(
    () => J(n, {
      className: o,
      onClick: (i) => {
        var d, l, b, u, p;
        (d = n.onClick) == null || d.call(n, i), c ? (b = s == null ? void 0 : (l = s.pin).dispatch) == null || b.call(l, {
          msg: "clear_pin"
        }) : (p = s == null ? void 0 : (u = s.pin).dispatch) == null || p.call(u, {
          msg: "set_pin",
          trackReference: t
        });
      }
    }),
    [n, o, t, c, s == null ? void 0 : s.pin]
  ), inFocus: c };
}
function Dn(e, n, t = {}) {
  const s = t.gridLayouts ?? ze, { width: o, height: c } = Vt(e), a = We(s, n, o, c);
  return r.useEffect(() => {
    e.current && a && (e.current.style.setProperty("--lk-col-count", a == null ? void 0 : a.columns.toString()), e.current.style.setProperty("--lk-row-count", a == null ? void 0 : a.rows.toString()));
  }, [e, a]), {
    layout: a,
    containerWidth: o,
    containerHeight: c
  };
}
function ve(e, n = {}) {
  var i, d;
  const t = typeof e == "string" ? n.participant : e.participant, s = Q(t), o = typeof e == "string" ? { participant: s, source: e } : e, [c, a] = r.useState(
    !!((i = o.publication) != null && i.isMuted || (d = s.getTrackPublication(o.source)) != null && d.isMuted)
  );
  return r.useEffect(() => {
    const l = Ge(o).subscribe(a);
    return () => l.unsubscribe();
  }, [ue(o)]), c;
}
function Bt(e) {
  const n = Q(e), t = r.useMemo(() => Je(n), [n]);
  return A(t, n.isSpeaking);
}
function De(e = {}) {
  const n = x(e.room), [t, s] = r.useState(n.localParticipant), [o, c] = r.useState(
    t.isMicrophoneEnabled
  ), [a, i] = r.useState(t.isCameraEnabled), [d, l] = r.useState(
    t.isScreenShareEnabled
  ), [b, u] = r.useState(
    t.lastMicrophoneError
  ), [p, g] = r.useState(t.lastCameraError), [M, T] = r.useState(
    void 0
  ), [L, k] = r.useState(void 0), D = (R) => {
    i(R.isCameraEnabled), c(R.isMicrophoneEnabled), l(R.isScreenShareEnabled), k(R.cameraTrack), T(R.microphoneTrack), u(R.participant.lastMicrophoneError), g(R.participant.lastCameraError), s(R.participant);
  };
  return r.useEffect(() => {
    const R = $e(n.localParticipant).subscribe(D);
    return () => R.unsubscribe();
  }, [n]), {
    isMicrophoneEnabled: o,
    isScreenShareEnabled: d,
    isCameraEnabled: a,
    microphoneTrack: M,
    cameraTrack: L,
    lastMicrophoneError: b,
    lastCameraError: p,
    localParticipant: t
  };
}
function On() {
  const e = re(), n = r.useMemo(
    () => Pe(e.localParticipant),
    [e]
  );
  return A(n, e.localParticipant.permissions);
}
function In({
  kind: e,
  room: n,
  track: t,
  requestPermissions: s,
  onError: o
}) {
  const c = de(), a = r.useMemo(() => n ?? c ?? new Re(), [n, c]), i = r.useMemo(
    () => Le(e, o, s),
    [e, s, o]
  ), d = A(i, []), [l, b] = r.useState(
    (a == null ? void 0 : a.getActiveDevice(e)) ?? "default"
  ), { className: u, activeDeviceObservable: p, setActiveMediaDevice: g } = r.useMemo(
    () => Qe(e, a),
    [e, a, t]
  );
  return r.useEffect(() => {
    const M = p.subscribe((T) => {
      T && (V.info("setCurrentDeviceId", T), b(T));
    });
    return () => {
      M == null || M.unsubscribe();
    };
  }, [p]), { devices: d, className: u, activeDeviceId: l, setActiveMediaDevice: g };
}
function Nn({
  kind: e,
  onError: n
}) {
  const t = r.useMemo(
    () => Le(e, n),
    [e, n]
  );
  return A(t, []);
}
function jt(e, n, t = {}) {
  const s = r.useRef([]), o = r.useRef(-1), c = n !== o.current, a = typeof t.customSortFunction == "function" ? t.customSortFunction(e) : Ke(e);
  let i = [...a];
  if (c === !1)
    try {
      i = Ye(s.current, a, n);
    } catch (d) {
      V.error("Error while running updatePages(): ", d);
    }
  return c ? s.current = a : s.current = i, o.current = n, i;
}
function _n(e, n) {
  const [t, s] = r.useState(1), o = Math.max(Math.ceil(n.length / e), 1);
  t > o && s(o);
  const c = t * e, a = c - e, i = (u) => {
    s((p) => u === "next" ? p === o ? p : p + 1 : p === 1 ? p : p - 1);
  }, d = (u) => {
    u > o ? s(o) : u < 1 ? s(1) : s(u);
  }, b = jt(n, e).slice(a, c);
  return {
    totalPageCount: o,
    nextPage: () => i("next"),
    prevPage: () => i("previous"),
    setPage: d,
    firstItemIndex: a,
    lastItemIndex: c,
    tracks: b,
    currentPage: t
  };
}
function Fn(e = {}) {
  let n = le();
  e.participant && (n = e.participant);
  const t = r.useMemo(() => Xe(n), [n]), { identity: s, name: o, metadata: c } = A(t, {
    name: n == null ? void 0 : n.name,
    identity: n == null ? void 0 : n.identity,
    metadata: n == null ? void 0 : n.metadata
  });
  return { identity: s, name: o, metadata: c };
}
function xn(e = {}) {
  const n = Q(e.participant), t = r.useMemo(() => Pe(n), [n]);
  return A(t, n.permissions);
}
function Un({
  trackRef: e,
  onParticipantClick: n,
  disableSpeakingIndicator: t,
  htmlProps: s
}) {
  const o = ie(e), c = r.useMemo(() => {
    const { className: p } = Ze();
    return J(s, {
      className: p,
      onClick: (g) => {
        var M;
        if ((M = s.onClick) == null || M.call(s, g), typeof n == "function") {
          const T = o.publication ?? o.participant.getTrackPublication(o.source);
          n({ participant: o.participant, track: T });
        }
      }
    });
  }, [
    s,
    n,
    o.publication,
    o.source,
    o.participant
  ]), a = o.participant.getTrackPublication(w.Source.Microphone), i = r.useMemo(() => ({
    participant: o.participant,
    source: w.Source.Microphone,
    publication: a
  }), [a, o.participant]), d = ve(o), l = ve(i), b = Bt(o.participant), u = qt(o);
  return {
    elementProps: {
      "data-lk-audio-muted": l,
      "data-lk-video-muted": d,
      "data-lk-speaking": t === !0 ? !1 : b,
      "data-lk-local-participant": o.participant.isLocal,
      "data-lk-source": o.source,
      "data-lk-facing-mode": u,
      ...c
    }
  };
}
function me(e = {}) {
  const n = x(e.room), [t, s] = r.useState([]);
  return r.useEffect(() => {
    const o = et(n, {
      additionalRoomEvents: e.updateOnlyOn
    }).subscribe(s);
    return () => o.unsubscribe();
  }, [n, JSON.stringify(e.updateOnlyOn)]), t;
}
function zt(e = {}) {
  const n = me(e), { localParticipant: t } = De(e);
  return r.useMemo(
    () => [t, ...n],
    [t, n]
  );
}
function Hn(e) {
  return e = tt(e), r.useMemo(() => (e == null ? void 0 : e.pin.state) !== void 0 && e.pin.state.length >= 1 ? e.pin.state : [], [e.pin.state]);
}
function Vn(e, n = {}) {
  const t = re(), [s] = r.useState(n.updateOnlyOn), o = r.useMemo(() => typeof e == "string" ? nt(t, e, {
    additionalEvents: s
  }) : st(t, e, {
    additionalEvents: s
  }), [t, JSON.stringify(e), s]), [c, a] = r.useState({
    p: void 0
  });
  return r.useEffect(() => {
    const i = o.subscribe((d) => a({ p: d }));
    return () => i.unsubscribe();
  }, [o]), c.p;
}
function qn(e = {}) {
  const n = x(e.room), t = r.useMemo(() => rt(n), [n]), { name: s, metadata: o } = A(t, {
    name: n.name,
    metadata: n.metadata
  });
  return { name: s, metadata: o };
}
function Wt(e) {
  const n = x(e == null ? void 0 : e.room), t = r.useMemo(() => ot(n), [n]);
  return A(t, n.activeSpeakers);
}
function Bn(e) {
  const [n, t] = r.useState(
    ge(e)
  ), s = Wt();
  return r.useEffect(() => {
    t(ge(e));
  }, [s, e]), n;
}
function jn({ room: e, props: n }) {
  const t = x(e), { className: s, roomAudioPlaybackAllowedObservable: o, handleStartAudioPlayback: c } = r.useMemo(
    () => at(),
    []
  ), a = r.useMemo(
    () => o(t),
    [t, o]
  ), { canPlayAudio: i } = A(a, {
    canPlayAudio: t.canPlaybackAudio
  });
  return { mergedProps: r.useMemo(
    () => J(n, {
      className: s,
      onClick: () => {
        c(t);
      },
      style: { display: i ? "none" : "block" }
    }),
    [n, s, i, c, t]
  ), canPlayAudio: i };
}
function zn({ room: e, props: n }) {
  const t = x(e), { className: s, roomVideoPlaybackAllowedObservable: o, handleStartVideoPlayback: c } = r.useMemo(
    () => ct(),
    []
  ), a = r.useMemo(
    () => o(t),
    [t, o]
  ), { canPlayVideo: i } = A(a, {
    canPlayVideo: t.canPlaybackVideo
  });
  return { mergedProps: r.useMemo(
    () => J(n, {
      className: s,
      onClick: () => {
        c(t);
      },
      style: { display: i ? "none" : "block" }
    }),
    [n, s, i, c, t]
  ), canPlayVideo: i };
}
function Wn(e, n = {}) {
  const t = r.useRef(null), s = r.useRef(null), o = n.minSwipeDistance ?? 50, c = (d) => {
    s.current = null, t.current = d.targetTouches[0].clientX;
  }, a = (d) => {
    s.current = d.targetTouches[0].clientX;
  }, i = r.useCallback(() => {
    if (!t.current || !s.current)
      return;
    const d = t.current - s.current, l = d > o, b = d < -o;
    l && n.onLeftSwipe && n.onLeftSwipe(), b && n.onRightSwipe && n.onRightSwipe();
  }, [o, n]);
  r.useEffect(() => {
    const d = e.current;
    return d && (d.addEventListener("touchstart", c, { passive: !0 }), d.addEventListener("touchmove", a, { passive: !0 }), d.addEventListener("touchend", i, { passive: !0 })), () => {
      d && (d.removeEventListener("touchstart", c), d.removeEventListener("touchmove", a), d.removeEventListener("touchend", i));
    };
  }, [e, i]);
}
function Gn({ props: e }) {
  const { dispatch: n, state: t } = we().widget, { className: s } = r.useMemo(() => it(), []);
  return { mergedProps: r.useMemo(() => J(e, {
    className: s,
    onClick: () => {
      n && n({ msg: "toggle_chat" });
    },
    "aria-pressed": t != null && t.showChat ? "true" : "false",
    "data-lk-unread-msgs": t ? t.unreadMessages < 10 ? t.unreadMessages.toFixed(0) : "9+" : "0"
  }), [e, s, n, t]) };
}
function Jn(e, n, t = {}) {
  const [s, o] = r.useState(void 0);
  return r.useEffect(() => {
    var a;
    if (e === void 0)
      throw Error("token endpoint needs to be defined");
    if (((a = t.userInfo) == null ? void 0 : a.identity) === void 0)
      return;
    (async () => {
      V.debug("fetching token");
      const i = new URLSearchParams({ ...t.userInfo, roomName: n }), d = await fetch(`${e}?${i.toString()}`);
      if (!d.ok) {
        V.error(
          `Could not fetch token. Server responded with status ${d.status}: ${d.statusText}`
        );
        return;
      }
      const { accessToken: l } = await d.json();
      o(l);
    })();
  }, [e, n, JSON.stringify(t)]), s;
}
function $n(e) {
  var c, a;
  const n = ie(e), { className: t, mediaMutedObserver: s } = r.useMemo(
    () => ut(n),
    [ue(n)]
  );
  return { isMuted: A(
    s,
    !!((c = n.publication) != null && c.isMuted || (a = n.participant.getTrackPublication(n.source)) != null && a.isMuted)
  ), className: t };
}
function Qn({
  source: e,
  onChange: n,
  initialState: t,
  captureOptions: s,
  publishOptions: o,
  onDeviceError: c,
  room: a,
  ...i
}) {
  var m;
  const d = de(), l = r.useMemo(() => a ?? d, [a, d]), b = (m = l == null ? void 0 : l.localParticipant) == null ? void 0 : m.getTrackPublication(e), u = r.useRef(!1), { toggle: p, className: g, pendingObserver: M, enabledObserver: T } = r.useMemo(
    () => l ? dt(e, l, s, o, c) : lt(),
    [l, e, JSON.stringify(s), o]
  ), L = A(M, !1), k = A(T, t ?? !!(b != null && b.isEnabled));
  r.useEffect(() => {
    n == null || n(k, u.current), u.current = !1;
  }, [k, n]), r.useEffect(() => {
    t !== void 0 && (V.debug("forcing initial toggle state", e, t), p(t));
  }, []);
  const D = r.useMemo(() => J(i, { className: g }), [i, g]), R = r.useCallback(
    (f) => {
      var h;
      u.current = !0, p().catch(() => u.current = !1), (h = i.onClick) == null || h.call(i, f);
    },
    [i, p]
  );
  return {
    toggle: p,
    enabled: k,
    pending: L,
    track: b,
    buttonProps: {
      ...D,
      "aria-pressed": k,
      "data-lk-source": e,
      "data-lk-enabled": k,
      disabled: L,
      onClick: R
    }
  };
}
function Kn(e = [
  w.Source.Camera,
  w.Source.Microphone,
  w.Source.ScreenShare,
  w.Source.ScreenShareAudio,
  w.Source.Unknown
], n = {}) {
  const t = x(n.room), [s, o] = r.useState([]), [c, a] = r.useState([]), i = r.useMemo(() => e.map((l) => ft(l) ? l.source : l), [JSON.stringify(e)]);
  return r.useEffect(() => {
    const l = mt(t, i, {
      additionalRoomEvents: n.updateOnlyOn,
      onlySubscribed: n.onlySubscribed
    }).subscribe(({ trackReferences: b, participants: u }) => {
      V.debug("setting track bundles", b, u), o(b), a(u);
    });
    return () => l.unsubscribe();
  }, [
    t,
    JSON.stringify(n.onlySubscribed),
    JSON.stringify(n.updateOnlyOn),
    JSON.stringify(e)
  ]), r.useMemo(() => {
    if (Ae(e)) {
      const l = Jt(e, c), b = Array.from(s);
      return c.forEach((u) => {
        l.has(u.identity) && (l.get(u.identity) ?? []).forEach((g) => {
          if (s.find(
            ({ participant: T, publication: L }) => u.identity === T.identity && L.source === g
          ))
            return;
          V.debug(
            `Add ${g} placeholder for participant ${u.identity}.`
          );
          const M = {
            participant: u,
            source: g
          };
          b.push(M);
        });
      }), b;
    } else
      return s;
  }, [s, c, e]);
}
function Gt(e, n) {
  const t = new Set(e);
  for (const s of n)
    t.delete(s);
  return t;
}
function Jt(e, n) {
  const t = /* @__PURE__ */ new Map();
  if (Ae(e)) {
    const s = e.filter((o) => o.withPlaceholder).map((o) => o.source);
    n.forEach((o) => {
      const c = o.getTrackPublications().map((i) => {
        var d;
        return (d = i.track) == null ? void 0 : d.source;
      }).filter((i) => i !== void 0), a = Array.from(
        Gt(new Set(s), new Set(c))
      );
      a.length > 0 && t.set(o.identity, a);
    });
  }
  return t;
}
function $t(e) {
  const [n, t] = r.useState(pt(e)), { trackObserver: s } = r.useMemo(() => ht(e), [e.participant.sid ?? e.participant.identity, e.source]);
  return r.useEffect(() => {
    const o = s.subscribe((c) => {
      t(c);
    });
    return () => o == null ? void 0 : o.unsubscribe();
  }, [s]), {
    participant: e.participant,
    source: e.source ?? w.Source.Unknown,
    publication: n
  };
}
function Yn(e, n) {
  const t = Q(n);
  return $t({ name: e, participant: t });
}
function Qt(e) {
  const n = x(e == null ? void 0 : e.room), t = ee(n), s = r.useMemo(
    () => t === O.Disconnected,
    [t]
  ), o = r.useMemo(
    () => bt(n, e),
    [n, e, s]
  ), c = A(o.isSendingObservable, !1), a = A(o.messageObservable, []);
  return { send: o.send, chatMessages: a, isSending: c };
}
function Xn(e = {}) {
  const [n, t] = r.useState(
    gt(e.defaults, e.preventLoad ?? !1)
  ), s = r.useCallback((d) => {
    t((l) => ({ ...l, audioEnabled: d }));
  }, []), o = r.useCallback((d) => {
    t((l) => ({ ...l, videoEnabled: d }));
  }, []), c = r.useCallback((d) => {
    t((l) => ({ ...l, audioDeviceId: d }));
  }, []), a = r.useCallback((d) => {
    t((l) => ({ ...l, videoDeviceId: d }));
  }, []), i = r.useCallback((d) => {
    t((l) => ({ ...l, username: d }));
  }, []);
  return r.useEffect(() => {
    vt(n, e.preventSave ?? !1);
  }, [n, e.preventSave]), {
    userChoices: n,
    saveAudioInputEnabled: s,
    saveVideoInputEnabled: o,
    saveAudioInputDeviceId: c,
    saveVideoInputDeviceId: a,
    saveUsername: i
  };
}
function Zn(e, n = {}) {
  const t = Q(e), s = x(n.room), o = r.useMemo(() => St(s, t), [s, t]);
  return A(
    o,
    t.isLocal ? t.isE2EEEnabled : !!(t != null && t.isEncrypted)
  );
}
function es(e, n = { fftSize: 32, smoothingTimeConstant: 0 }) {
  const t = yt(e) ? e.publication.track : e, [s, o] = r.useState(0);
  return r.useEffect(() => {
    if (!t || !t.mediaStream)
      return;
    const { cleanup: c, analyser: a } = fe(t, n), i = a.frequencyBinCount, d = new Uint8Array(i), b = setInterval(() => {
      a.getByteFrequencyData(d);
      let u = 0;
      for (let p = 0; p < d.length; p++) {
        const g = d[p];
        u += g * g;
      }
      o(Math.sqrt(u / d.length) / 255);
    }, 1e3 / 30);
    return () => {
      c(), clearInterval(b);
    };
  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n)]), s;
}
const Kt = (e) => {
  const n = (t) => {
    let c = 1 - Math.max(-100, Math.min(-10, t)) * -1 / 100;
    return c = Math.sqrt(c), c;
  };
  return e.map((t) => t === -1 / 0 ? 0 : n(t));
}, Yt = {
  bands: 5,
  loPass: 100,
  hiPass: 600,
  updateInterval: 32,
  analyserOptions: { fftSize: 2048 }
};
function ts(e, n = {}) {
  var a;
  const t = e instanceof w ? e : (a = e == null ? void 0 : e.publication) == null ? void 0 : a.track, s = { ...Yt, ...n }, [o, c] = r.useState(
    new Array(s.bands).fill(0)
  );
  return r.useEffect(() => {
    if (!t || !(t != null && t.mediaStream)) {
      c((g) => g.slice().fill(0));
      return;
    }
    const { analyser: i, cleanup: d } = fe(t, s.analyserOptions), l = i.frequencyBinCount, b = new Float32Array(l), p = setInterval(() => {
      i.getFloatFrequencyData(b);
      let g = new Float32Array(b.length);
      for (let k = 0; k < b.length; k++)
        g[k] = b[k];
      g = g.slice(n.loPass, n.hiPass);
      const M = Kt(g), T = Math.ceil(M.length / s.bands), L = [];
      for (let k = 0; k < s.bands; k++) {
        const D = M.slice(k * T, (k + 1) * T).reduce((R, m) => R += m, 0);
        L.push(D / T);
      }
      c(L);
    }, s.updateInterval);
    return () => {
      d(), clearInterval(p);
    };
  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n)]), o;
}
const Xt = {
  barCount: 120,
  volMultiplier: 5,
  updateInterval: 20
};
function ns(e, n = {}) {
  var b;
  const t = e instanceof w ? e : (b = e == null ? void 0 : e.publication) == null ? void 0 : b.track, s = { ...Xt, ...n }, o = r.useRef(new Float32Array()), c = r.useRef(performance.now()), a = r.useRef(0), [i, d] = r.useState([]), l = r.useCallback((u) => {
    d(
      Array.from(
        en(u, s.barCount).map((p) => Math.sqrt(p) * s.volMultiplier)
        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),
      )
    );
  }, []);
  return r.useEffect(() => {
    if (!t || !(t != null && t.mediaStream))
      return;
    const { analyser: u, cleanup: p } = fe(t, {
      fftSize: Se(s.barCount)
    }), g = Se(s.barCount), M = new Float32Array(g), T = () => {
      if (L = requestAnimationFrame(T), u.getFloatTimeDomainData(M), o.current.map((k, D) => k + M[D]), a.current += 1, performance.now() - c.current >= s.updateInterval) {
        const k = M.map((D) => D / a.current);
        l(k), c.current = performance.now(), a.current = 0;
      }
    };
    let L = requestAnimationFrame(T);
    return () => {
      p(), cancelAnimationFrame(L);
    };
  }, [t, t == null ? void 0 : t.mediaStream, JSON.stringify(n), l]), {
    bars: i
  };
}
function Se(e) {
  return e < 32 ? 32 : Zt(e);
}
function Zt(e) {
  let n = 2;
  for (; e >>= 1; )
    n <<= 1;
  return n;
}
function en(e, n) {
  const t = Math.floor(e.length / n), s = new Float32Array(n);
  for (let o = 0; o < n; o++) {
    const c = t * o;
    let a = 0;
    for (let i = 0; i < t; i++)
      a = a + Math.abs(e[c + i]);
    s[o] = a / t;
  }
  return s;
}
function se(e, n = {}) {
  let t, s;
  typeof n == "string" ? t = n : (t = n == null ? void 0 : n.participantIdentity, s = n == null ? void 0 : n.room);
  const o = le(), c = zt({ room: s, updateOnlyOn: [] }), a = r.useMemo(() => t ? c.find((l) => l.identity === t) : o, [t, c, o]), i = r.useMemo(() => {
    if (a)
      return Ct(a, { sources: e });
  }, [a, JSON.stringify(e)]);
  return A(i, []);
}
function tn(e) {
  var t, s, o;
  const n = r.useMemo(
    () => {
      var c;
      return (c = e == null ? void 0 : e.publication) != null && c.track ? Mt(e == null ? void 0 : e.publication.track) : void 0;
    },
    [(t = e == null ? void 0 : e.publication) == null ? void 0 : t.track]
  );
  return A(n, {
    timestamp: Date.now(),
    rtpTimestamp: (o = (s = e == null ? void 0 : e.publication) == null ? void 0 : s.track) == null ? void 0 : o.rtpTimestamp
  });
}
const nn = {
  bufferSize: 100
  // maxAge: 2_000,
};
function sn(e, n) {
  const t = { ...nn, ...n }, [s, o] = r.useState([]), c = tn(e), a = (i) => {
    var d;
    (d = t.onTranscription) == null || d.call(t, i), o(
      (l) => Tt(
        l,
        // when first receiving a segment, add the current media timestamp to it
        i.map((b) => kt(b, c)),
        t.bufferSize
      )
    );
  };
  return r.useEffect(() => {
    if (!(e != null && e.publication))
      return;
    const i = Et(e.publication).subscribe((d) => {
      a(...d);
    });
    return () => {
      i.unsubscribe();
    };
  }, [e && ue(e), a]), { segments: s };
}
function rn(e = {}) {
  const n = le(), t = e.participant ?? n, s = r.useMemo(
    // weird typescript constraint
    () => t ? ce(t) : ce(t),
    [t]
  );
  return A(s, {
    attributes: t == null ? void 0 : t.attributes
  });
}
function ss(e, n = {}) {
  const t = Q(n.participant), [s, o] = r.useState(t.attributes[e]);
  return r.useEffect(() => {
    if (!t)
      return;
    const c = ce(t).subscribe((a) => {
      a.changed[e] !== void 0 && o(a.attributes[e]);
    });
    return () => {
      c.unsubscribe();
    };
  }, [t, e]), s;
}
const ye = G.AgentState;
function rs() {
  const e = me(), n = e.find(
    (u) => u.kind === ne.AGENT && !(G.PublishOnBehalf in u.attributes)
  ), t = e.find(
    (u) => u.kind === ne.AGENT && u.attributes[G.PublishOnBehalf] === (n == null ? void 0 : n.identity)
  ), s = se(
    [w.Source.Microphone, w.Source.Camera],
    n == null ? void 0 : n.identity
  ), o = se(
    [w.Source.Microphone, w.Source.Camera],
    t == null ? void 0 : t.identity
  ), c = s.find((u) => u.source === w.Source.Microphone) ?? o.find((u) => u.source === w.Source.Microphone), a = s.find((u) => u.source === w.Source.Camera) ?? o.find((u) => u.source === w.Source.Camera), { segments: i } = sn(c), d = ee(), { attributes: l } = rn({ participant: n }), b = r.useMemo(() => d === O.Disconnected ? "disconnected" : d === O.Connecting || !n || !(l != null && l[ye]) ? "connecting" : l[ye], [l, n, d]);
  return {
    agent: n,
    state: b,
    audioTrack: c,
    videoTrack: a,
    agentTranscriptions: i,
    agentAttributes: l
  };
}
function os(e) {
  const n = x(e), t = ee(n), s = r.useMemo(() => wt(n), [n, t]);
  return A(s, n.isRecording);
}
function on(e, n) {
  const t = x(n == null ? void 0 : n.room), o = ee(t) === O.Disconnected, c = r.useMemo(() => Pt(t, e), [t, e]);
  return { textStreams: A(o ? void 0 : c, []) };
}
function an(e) {
  const { participantIdentities: n, trackSids: t } = e ?? {}, { textStreams: s } = on(Lt.TRANSCRIPTION, { room: e == null ? void 0 : e.room });
  return r.useMemo(
    () => s.filter(
      (c) => n ? n.includes(c.participantInfo.identity) : !0
    ).filter(
      (c) => {
        var a;
        return t ? t.includes(
          ((a = c.streamInfo.attributes) == null ? void 0 : a[G.TranscribedTrackId]) ?? ""
        ) : !0;
      }
    ),
    [s, n, t]
  );
}
const Ce = 2, Me = 400, Ee = 3, Te = 1e3;
function as(e) {
  const n = oe([]), t = Ie(() => new It(), []), s = Z(async () => t.lock().then(async (b) => {
    for (; ; ) {
      const u = n.current.pop();
      if (!u) {
        b();
        break;
      }
      switch (u.type) {
        case "connect":
          await u.room.connect(...u.args).then(u.resolve).catch(u.reject);
          break;
        case "disconnect":
          await u.room.disconnect(...u.args).then(u.resolve).catch(u.reject);
          break;
      }
    }
  }), []), o = oe([]), c = Z((b) => {
    let u = 0;
    o.current = o.current.filter((p) => {
      const g = b.getTime() - p.getTime() < Te;
      return g && (u += 1), g;
    }), u > Ee && V.warn(
      `useSequentialRoomConnectDisconnect: room changed reference rapidly (over ${Ee}x in ${Te}ms). This is not recommended.`
    );
  }, []);
  Ne(() => {
    n.current = [];
    const b = /* @__PURE__ */ new Date();
    o.current.push(b), c(b);
  }, [e, c]);
  const a = oe([]), i = Z((b) => {
    let u = 0;
    a.current = a.current.filter((p) => {
      const g = b.getTime() - p.getTime() < Me;
      return g && (u += 1), g;
    }), u > Ce && V.warn(
      `useSequentialRoomConnectDisconnect: room connect / disconnect occurring in rapid sequence (over ${Ce}x in ${Me}ms). This is not recommended and may be the sign of a bug like a useEffect dependency changing every render.`
    );
  }, []), d = Z(
    async (...b) => new Promise((u, p) => {
      if (!e)
        throw new Error("Called connect(), but room was unset");
      const g = /* @__PURE__ */ new Date();
      i(g), n.current.push({ type: "connect", room: e, args: b, resolve: u, reject: p }), a.current.push(g), s();
    }),
    [e, i, s]
  ), l = Z(
    async (...b) => new Promise((u, p) => {
      if (!e)
        throw new Error("Called discconnect(), but room was unset");
      const g = /* @__PURE__ */ new Date();
      i(g), n.current.push({ type: "disconnect", room: e, args: b, resolve: u, reject: p }), a.current.push(g), s();
    }),
    [e, i, s]
  );
  return {
    connect: e ? d : null,
    disconnect: e ? l : null
  };
}
var te = { exports: {} }, ke;
function cn() {
  if (ke) return te.exports;
  ke = 1;
  var e = typeof Reflect == "object" ? Reflect : null, n = e && typeof e.apply == "function" ? e.apply : function(f, h, v) {
    return Function.prototype.apply.call(f, h, v);
  }, t;
  e && typeof e.ownKeys == "function" ? t = e.ownKeys : Object.getOwnPropertySymbols ? t = function(f) {
    return Object.getOwnPropertyNames(f).concat(Object.getOwnPropertySymbols(f));
  } : t = function(f) {
    return Object.getOwnPropertyNames(f);
  };
  function s(m) {
    console && console.warn && console.warn(m);
  }
  var o = Number.isNaN || function(f) {
    return f !== f;
  };
  function c() {
    c.init.call(this);
  }
  te.exports = c, te.exports.once = k, c.EventEmitter = c, c.prototype._events = void 0, c.prototype._eventsCount = 0, c.prototype._maxListeners = void 0;
  var a = 10;
  function i(m) {
    if (typeof m != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof m);
  }
  Object.defineProperty(c, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return a;
    },
    set: function(m) {
      if (typeof m != "number" || m < 0 || o(m))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + m + ".");
      a = m;
    }
  }), c.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, c.prototype.setMaxListeners = function(f) {
    if (typeof f != "number" || f < 0 || o(f))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + f + ".");
    return this._maxListeners = f, this;
  };
  function d(m) {
    return m._maxListeners === void 0 ? c.defaultMaxListeners : m._maxListeners;
  }
  c.prototype.getMaxListeners = function() {
    return d(this);
  }, c.prototype.emit = function(f) {
    for (var h = [], v = 1; v < arguments.length; v++) h.push(arguments[v]);
    var C = f === "error", E = this._events;
    if (E !== void 0)
      C = C && E.error === void 0;
    else if (!C)
      return !1;
    if (C) {
      var y;
      if (h.length > 0 && (y = h[0]), y instanceof Error)
        throw y;
      var I = new Error("Unhandled error." + (y ? " (" + y.message + ")" : ""));
      throw I.context = y, I;
    }
    var U = E[f];
    if (U === void 0)
      return !1;
    if (typeof U == "function")
      n(U, this, h);
    else
      for (var q = U.length, B = M(U, q), v = 0; v < q; ++v)
        n(B[v], this, h);
    return !0;
  };
  function l(m, f, h, v) {
    var C, E, y;
    if (i(h), E = m._events, E === void 0 ? (E = m._events = /* @__PURE__ */ Object.create(null), m._eventsCount = 0) : (E.newListener !== void 0 && (m.emit(
      "newListener",
      f,
      h.listener ? h.listener : h
    ), E = m._events), y = E[f]), y === void 0)
      y = E[f] = h, ++m._eventsCount;
    else if (typeof y == "function" ? y = E[f] = v ? [h, y] : [y, h] : v ? y.unshift(h) : y.push(h), C = d(m), C > 0 && y.length > C && !y.warned) {
      y.warned = !0;
      var I = new Error("Possible EventEmitter memory leak detected. " + y.length + " " + String(f) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      I.name = "MaxListenersExceededWarning", I.emitter = m, I.type = f, I.count = y.length, s(I);
    }
    return m;
  }
  c.prototype.addListener = function(f, h) {
    return l(this, f, h, !1);
  }, c.prototype.on = c.prototype.addListener, c.prototype.prependListener = function(f, h) {
    return l(this, f, h, !0);
  };
  function b() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function u(m, f, h) {
    var v = { fired: !1, wrapFn: void 0, target: m, type: f, listener: h }, C = b.bind(v);
    return C.listener = h, v.wrapFn = C, C;
  }
  c.prototype.once = function(f, h) {
    return i(h), this.on(f, u(this, f, h)), this;
  }, c.prototype.prependOnceListener = function(f, h) {
    return i(h), this.prependListener(f, u(this, f, h)), this;
  }, c.prototype.removeListener = function(f, h) {
    var v, C, E, y, I;
    if (i(h), C = this._events, C === void 0)
      return this;
    if (v = C[f], v === void 0)
      return this;
    if (v === h || v.listener === h)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete C[f], C.removeListener && this.emit("removeListener", f, v.listener || h));
    else if (typeof v != "function") {
      for (E = -1, y = v.length - 1; y >= 0; y--)
        if (v[y] === h || v[y].listener === h) {
          I = v[y].listener, E = y;
          break;
        }
      if (E < 0)
        return this;
      E === 0 ? v.shift() : T(v, E), v.length === 1 && (C[f] = v[0]), C.removeListener !== void 0 && this.emit("removeListener", f, I || h);
    }
    return this;
  }, c.prototype.off = c.prototype.removeListener, c.prototype.removeAllListeners = function(f) {
    var h, v, C;
    if (v = this._events, v === void 0)
      return this;
    if (v.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : v[f] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete v[f]), this;
    if (arguments.length === 0) {
      var E = Object.keys(v), y;
      for (C = 0; C < E.length; ++C)
        y = E[C], y !== "removeListener" && this.removeAllListeners(y);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (h = v[f], typeof h == "function")
      this.removeListener(f, h);
    else if (h !== void 0)
      for (C = h.length - 1; C >= 0; C--)
        this.removeListener(f, h[C]);
    return this;
  };
  function p(m, f, h) {
    var v = m._events;
    if (v === void 0)
      return [];
    var C = v[f];
    return C === void 0 ? [] : typeof C == "function" ? h ? [C.listener || C] : [C] : h ? L(C) : M(C, C.length);
  }
  c.prototype.listeners = function(f) {
    return p(this, f, !0);
  }, c.prototype.rawListeners = function(f) {
    return p(this, f, !1);
  }, c.listenerCount = function(m, f) {
    return typeof m.listenerCount == "function" ? m.listenerCount(f) : g.call(m, f);
  }, c.prototype.listenerCount = g;
  function g(m) {
    var f = this._events;
    if (f !== void 0) {
      var h = f[m];
      if (typeof h == "function")
        return 1;
      if (h !== void 0)
        return h.length;
    }
    return 0;
  }
  c.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t(this._events) : [];
  };
  function M(m, f) {
    for (var h = new Array(f), v = 0; v < f; ++v)
      h[v] = m[v];
    return h;
  }
  function T(m, f) {
    for (; f + 1 < m.length; f++)
      m[f] = m[f + 1];
    m.pop();
  }
  function L(m) {
    for (var f = new Array(m.length), h = 0; h < f.length; ++h)
      f[h] = m[h].listener || m[h];
    return f;
  }
  function k(m, f) {
    return new Promise(function(h, v) {
      function C(y) {
        m.removeListener(f, E), v(y);
      }
      function E() {
        typeof m.removeListener == "function" && m.removeListener("error", C), h([].slice.call(arguments));
      }
      R(m, f, E, { once: !0 }), f !== "error" && D(m, C, { once: !0 });
    });
  }
  function D(m, f, h) {
    typeof m.on == "function" && R(m, "error", f, h);
  }
  function R(m, f, h, v) {
    if (typeof m.on == "function")
      v.once ? m.once(f, h) : m.on(f, h);
    else if (typeof m.addEventListener == "function")
      m.addEventListener(f, function C(E) {
        v.once && m.removeEventListener(f, C), h(E);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof m);
  }
  return te.exports;
}
var pe = cn();
const un = 2e4;
var dn = /* @__PURE__ */ ((e) => (e.CameraChanged = "cameraChanged", e.MicrophoneChanged = "microphoneChanged", e.StateChanged = "stateChanged", e))(dn || {});
const F = (e) => ({
  isConnected: e === "listening" || e === "thinking" || e === "speaking",
  canListen: e === "pre-connect-buffering" || e === "listening" || e === "thinking" || e === "speaking",
  isFinished: e === "disconnected" || e === "failed",
  isPending: e === "connecting" || e === "initializing" || e === "idle"
}), ln = () => {
  const [e, n] = r.useState(
    null
  ), [t, s] = r.useState(
    null
  ), o = r.useRef("connecting"), c = r.useRef(!1), a = (i) => setTimeout(() => {
    if (!c.current) {
      n("Agent did not join the room.");
      return;
    }
    const { isConnected: d } = F(o.current);
    if (!d) {
      n("Agent joined the room but did not complete initializing.");
      return;
    }
  }, i ?? un);
  return {
    agentTimeoutFailureReason: e,
    startAgentTimeout: r.useCallback(
      (i) => {
        t && clearTimeout(t), n(null), s(a(i)), o.current = "connecting", c.current = !1;
      },
      [t]
    ),
    clearAgentTimeout: r.useCallback(() => {
      t && clearTimeout(t), n(null), s(null), o.current = "connecting", c.current = !1;
    }, [t]),
    updateAgentTimeoutState: r.useCallback((i) => {
      o.current = i;
    }, []),
    updateAgentTimeoutParticipantExists: r.useCallback((i) => {
      c.current = i;
    }, [])
  };
};
function fn(e, n) {
  const t = r.useRef(n);
  r.useEffect(() => {
    t.current = n;
  }, [n]);
  const s = r.useCallback(
    async (a) => {
      const { isConnected: i } = F(t.current);
      if (!i)
        return new Promise((d, l) => {
          const b = (g) => {
            const { isConnected: M } = F(g);
            M && (p(), d());
          }, u = () => {
            p(), l(new Error("useAgent(/* ... */).waitUntilConnected - signal aborted"));
          }, p = () => {
            e.off("stateChanged", b), a == null || a.removeEventListener("abort", u);
          };
          e.on("stateChanged", b), a == null || a.addEventListener("abort", u);
        });
    },
    [e]
  ), o = r.useCallback(
    async (a) => {
      const { canListen: i } = F(t.current);
      if (!i)
        return new Promise((d, l) => {
          const b = (g) => {
            const { canListen: M } = F(g);
            M && (p(), d());
          }, u = () => {
            p(), l(new Error("useAgent(/* ... */).waitUntilCouldBeListening - signal aborted"));
          }, p = () => {
            e.off("stateChanged", b), a == null || a.removeEventListener("abort", u);
          };
          e.on("stateChanged", b), a == null || a.addEventListener("abort", u);
        });
    },
    [e]
  ), c = r.useCallback(
    async (a) => {
      const { isFinished: i } = F(t.current);
      if (!i)
        return new Promise((d, l) => {
          const b = (g) => {
            const { isFinished: M } = F(g);
            M && (p(), d());
          }, u = () => {
            p(), l(new Error("useAgent(/* ... */).waitUntilFinished - signal aborted"));
          }, p = () => {
            e.off("stateChanged", b), a == null || a.removeEventListener("abort", u);
          };
          e.on("stateChanged", b), a == null || a.addEventListener("abort", u);
        });
    },
    [e]
  );
  return { waitUntilConnected: s, waitUntilCouldBeListening: o, waitUntilFinished: c };
}
function Oe(e) {
  const n = At();
  if (e = e ?? n, !e)
    throw new Error(
      "No session provided, make sure you are inside a Session context or pass the session explicitly"
    );
  const {
    room: t,
    internal: {
      agentConnectTimeoutMilliseconds: s,
      agentTimeoutFailureReason: o,
      startAgentTimeout: c,
      clearAgentTimeout: a,
      updateAgentTimeoutState: i,
      updateAgentTimeoutParticipantExists: d
    }
  } = e, l = r.useMemo(() => new pe.EventEmitter(), []), b = me({ room: t }), u = r.useMemo(() => b.find(
    (S) => S.kind === ne.AGENT && !(G.PublishOnBehalf in S.attributes)
  ) ?? null, [b]), p = r.useMemo(() => u ? b.find(
    (S) => S.kind === ne.AGENT && S.attributes[G.PublishOnBehalf] === u.identity
  ) ?? null : null, [u, b]), [g, M] = r.useState({});
  r.useEffect(() => {
    if (!u)
      return;
    const S = (_) => {
      M(_);
    };
    return u.on(Y.AttributesChanged, S), () => {
      u.off(Y.AttributesChanged, S);
    };
  }, [u, l]);
  const T = se([w.Source.Camera, w.Source.Microphone], {
    room: t,
    participantIdentity: u == null ? void 0 : u.identity
  }), L = se([w.Source.Camera, w.Source.Microphone], {
    room: t,
    participantIdentity: p == null ? void 0 : p.identity
  }), k = r.useMemo(
    () => T.find((S) => S.source === w.Source.Camera) ?? L.find((S) => S.source === w.Source.Camera),
    [T, L]
  );
  r.useEffect(() => {
    l.emit("cameraChanged", k);
  }, [l, k]);
  const D = r.useMemo(
    () => T.find((S) => S.source === w.Source.Microphone) ?? L.find((S) => S.source === w.Source.Microphone),
    [T, L]
  );
  r.useEffect(() => {
    l.emit("microphoneChanged", D);
  }, [l, D]);
  const [R, m] = r.useState(t.state);
  r.useEffect(() => {
    const S = (_) => {
      m(_);
    };
    return t.on(H.ConnectionStateChanged, S), () => {
      t.off(H.ConnectionStateChanged, S);
    };
  }, [t]);
  const [f, h] = r.useState(null);
  r.useEffect(() => {
    if (!u)
      return;
    const S = (_) => {
      _.identity === (u == null ? void 0 : u.identity) && h("Agent left the room unexpectedly.");
    };
    return t.on(H.ParticipantDisconnected, S), () => {
      t.off(H.ParticipantDisconnected, S);
    };
  }, [u, t]), r.useEffect(() => {
    R === O.Disconnected && h(null);
  }, [R]);
  const [v, C] = r.useState(
    () => t.localParticipant.getTrackPublication(w.Source.Microphone) ?? null
  );
  r.useEffect(() => {
    const S = () => {
      C(t.localParticipant.getTrackPublication(w.Source.Microphone) ?? null);
    }, _ = () => {
      C(null);
    };
    return t.localParticipant.on(
      Y.LocalTrackPublished,
      S
    ), t.localParticipant.on(
      Y.LocalTrackUnpublished,
      _
    ), () => {
      t.localParticipant.off(
        Y.LocalTrackPublished,
        S
      ), t.localParticipant.off(
        Y.LocalTrackUnpublished,
        _
      );
    };
  }, [t.localParticipant]);
  const E = r.useMemo(() => {
    const S = [];
    return o && S.push(o), f && S.push(f), S;
  }, [o, f]), y = r.useMemo(() => {
    if (E.length > 0)
      return "failed";
    let S = "disconnected";
    return R !== O.Disconnected && (S = "connecting"), v && (S = "pre-connect-buffering"), u && g[G.AgentState] && (S = g[G.AgentState]), S;
  }, [
    E,
    R,
    v,
    u,
    g
  ]);
  r.useEffect(() => {
    l.emit("stateChanged", y), i(y);
  }, [l, y]), r.useEffect(() => {
    d(u !== null);
  }, [u]);
  const I = e.connectionState === "disconnected";
  r.useEffect(() => {
    if (!I)
      return c(s), () => {
        a();
      };
  }, [I, s]);
  const U = r.useMemo(() => {
    const S = {
      attributes: g,
      internal: {
        agentParticipant: u,
        workerParticipant: p,
        emitter: l
      }
    };
    switch (y) {
      case "disconnected":
        return {
          ...S,
          state: y,
          ...F(y),
          failureReasons: null,
          // Clear inner values if no longer connected
          cameraTrack: void 0,
          microphoneTrack: void 0
        };
      case "connecting":
        return {
          ...S,
          state: y,
          ...F(y),
          failureReasons: null,
          // Clear inner values if no longer connected
          cameraTrack: void 0,
          microphoneTrack: void 0
        };
      case "initializing":
      case "idle":
        return {
          ...S,
          state: y,
          ...F(y),
          failureReasons: null,
          cameraTrack: k,
          microphoneTrack: D
        };
      case "pre-connect-buffering":
        return {
          ...S,
          state: y,
          ...F(y),
          failureReasons: null,
          cameraTrack: k,
          microphoneTrack: D
        };
      case "listening":
      case "thinking":
      case "speaking":
        return {
          ...S,
          state: y,
          ...F(y),
          failureReasons: null,
          cameraTrack: k,
          microphoneTrack: D
        };
      case "failed":
        return {
          ...S,
          state: "failed",
          ...F("failed"),
          failureReasons: E,
          // Clear inner values if no longer connected
          cameraTrack: void 0,
          microphoneTrack: void 0
        };
    }
  }, [g, l, u, y, k, D]), { waitUntilConnected: q, waitUntilCouldBeListening: B, waitUntilFinished: P } = fn(l, y), N = r.useCallback(
    (S) => new Promise((_, K) => {
      const j = (W) => {
        W && ($(), _(W));
      }, z = () => {
        $(), K(new Error("useAgent(/* ... */).waitUntilCamera - signal aborted"));
      }, $ = () => {
        l.off("cameraChanged", j), S == null || S.removeEventListener("abort", z);
      };
      l.on("cameraChanged", j), S == null || S.addEventListener("abort", z);
    }),
    [l]
  ), X = r.useCallback(
    (S) => new Promise((_, K) => {
      const j = (W) => {
        W && ($(), _(W));
      }, z = () => {
        $(), K(new Error("useAgent(/* ... */).waitUntilMicrophone - signal aborted"));
      }, $ = () => {
        l.off("microphoneChanged", j), S == null || S.removeEventListener("abort", z);
      };
      l.on("microphoneChanged", j), S == null || S.addEventListener("abort", z);
    }),
    [l]
  );
  return r.useMemo(() => ({
    ...U,
    waitUntilConnected: q,
    waitUntilCouldBeListening: B,
    waitUntilFinished: P,
    waitUntilCamera: N,
    waitUntilMicrophone: X
  }), [
    U,
    q,
    B,
    P,
    N,
    X
  ]);
}
var mn = /* @__PURE__ */ ((e) => (e.ConnectionStateChanged = "connectionStateChanged", e.MediaDevicesError = "mediaDevicesError", e.EncryptionError = "encryptionError", e))(mn || {});
function pn(e, n) {
  const t = /* @__PURE__ */ new Set([...Object.keys(e), ...Object.keys(n)]);
  for (const s of t)
    switch (s) {
      case "roomName":
      case "participantName":
      case "participantIdentity":
      case "participantMetadata":
      case "participantAttributes":
      case "agentName":
      case "agentMetadata":
        if (e[s] !== n[s])
          return !1;
        break;
      default:
        const o = s;
        throw new Error(`Options key ${o} not being checked for equality!`);
    }
  return !0;
}
function hn(e, n) {
  const t = r.useRef(n);
  return r.useEffect(() => {
    t.current = n;
  }, [n]), r.useCallback(
    async (o, c) => {
      if (t.current !== o)
        return new Promise((a, i) => {
          const d = (u) => {
            u === o && (b(), a());
          }, l = () => {
            b(), i(
              new Error(
                `useSession(/* ... */).waitUntilConnectionState(${o}, /* signal */) - signal aborted`
              )
            );
          }, b = () => {
            e.off("connectionStateChanged", d), c == null || c.removeEventListener("abort", l);
          };
          e.on("connectionStateChanged", d), c == null || c.addEventListener("abort", l);
        });
    },
    [e]
  );
}
function bn(e, n) {
  const t = e instanceof _t, s = r.useRef(
    t ? n : null
  );
  return r.useEffect(() => {
    if (!t) {
      s.current = null;
      return;
    }
    s.current !== null && pn(s.current, n) || (s.current = n);
  }, [t, n]), r.useCallback(async () => {
    if (t) {
      if (!s.current)
        throw new Error(
          "AgentSession - memoized token fetch options are not set, but the passed tokenSource was an instance of TokenSourceConfigurable. If you are seeing this please make a new GitHub issue!"
        );
      return e.fetch(s.current);
    } else
      return e.fetch();
  }, [t, e]);
}
function cs(e, n = {}) {
  const { room: t, agentConnectTimeoutMilliseconds: s, ...o } = n, c = de(), a = r.useMemo(
    () => c ?? t ?? new Re(),
    [c, t]
  ), i = r.useMemo(
    () => new pe.EventEmitter(),
    []
  ), d = r.useCallback(
    (P) => ({
      isConnected: P === O.Connected || P === O.Reconnecting || P === O.SignalReconnecting
    }),
    []
  ), [l, b] = r.useState(a.state);
  r.useEffect(() => {
    const P = (N) => {
      b(N);
    };
    return a.on(H.ConnectionStateChanged, P), () => {
      a.off(H.ConnectionStateChanged, P);
    };
  }, [a]), r.useEffect(() => {
    const P = async (N) => {
      i.emit("mediaDevicesError", N);
    };
    return a.on(H.MediaDevicesError, P), () => {
      a.off(H.MediaDevicesError, P);
    };
  }, [a, i]), r.useEffect(() => {
    const P = async (N) => {
      i.emit("encryptionError", N);
    };
    return a.on(H.EncryptionError, P), () => {
      a.off(H.EncryptionError, P);
    };
  }, [a, i]);
  const { localParticipant: u } = De({ room: a }), p = u.getTrackPublication(w.Source.Camera), g = r.useMemo(() => !p || p.isMuted ? null : {
    source: w.Source.Camera,
    participant: u,
    publication: p
  }, [u, p, p == null ? void 0 : p.isMuted]), M = u.getTrackPublication(w.Source.Microphone), T = r.useMemo(() => !M || M.isMuted ? null : {
    source: w.Source.Microphone,
    participant: u,
    publication: M
  }, [u, M, M == null ? void 0 : M.isMuted]), {
    agentTimeoutFailureReason: L,
    startAgentTimeout: k,
    clearAgentTimeout: D,
    updateAgentTimeoutState: R,
    updateAgentTimeoutParticipantExists: m
  } = ln(), f = r.useMemo(
    () => ({
      emitter: i,
      tokenSource: e,
      agentConnectTimeoutMilliseconds: s,
      agentTimeoutFailureReason: L,
      startAgentTimeout: k,
      clearAgentTimeout: D,
      updateAgentTimeoutState: R,
      updateAgentTimeoutParticipantExists: m
    }),
    [
      i,
      s,
      e,
      L,
      k,
      D,
      R,
      m
    ]
  ), h = r.useMemo(() => {
    const P = {
      room: a,
      internal: f
    };
    switch (l) {
      case O.Connecting:
        return {
          ...P,
          connectionState: O.Connecting,
          ...d(O.Connecting),
          local: {
            cameraTrack: null,
            microphoneTrack: null
          }
        };
      case O.Connected:
      case O.Reconnecting:
      case O.SignalReconnecting:
        return {
          ...P,
          connectionState: l,
          ...d(l),
          local: {
            cameraTrack: g,
            microphoneTrack: T
          }
        };
      case O.Disconnected:
        return {
          ...P,
          connectionState: O.Disconnected,
          ...d(O.Disconnected),
          local: {
            cameraTrack: null,
            microphoneTrack: null
          }
        };
    }
  }, [
    f,
    a,
    l,
    g,
    T,
    d
  ]);
  r.useEffect(() => {
    i.emit("connectionStateChanged", h.connectionState);
  }, [i, h.connectionState]);
  const v = hn(
    i,
    h.connectionState
  ), C = r.useCallback(
    async (P) => v(
      O.Connected,
      P
    ),
    [v]
  ), E = r.useCallback(
    async (P) => v(O.Disconnected, P),
    [v]
  ), y = Oe(
    r.useMemo(
      () => ({
        connectionState: h.connectionState,
        room: a,
        internal: f
      }),
      [h, a, f]
    )
  ), I = bn(e, o), U = r.useCallback(
    async (P = {}) => {
      var j, z;
      const {
        signal: N,
        tracks: X = { microphone: { enabled: !0, publishOptions: { preConnectBuffer: !0 } } },
        roomConnectOptions: S
      } = P;
      await E(N);
      const _ = () => {
        a.disconnect();
      };
      N == null || N.addEventListener("abort", _);
      let K = !1;
      await Promise.all([
        I().then(({ serverUrl: $, participantToken: W }) => {
          var he, be;
          return K = (((be = (he = Nt(W).roomConfig) == null ? void 0 : he.agents) == null ? void 0 : be.length) ?? 0) > 0, a.connect($, W, S);
        }),
        // Start microphone (with preconnect buffer) by default
        (j = X.microphone) != null && j.enabled ? a.localParticipant.setMicrophoneEnabled(
          !0,
          void 0,
          ((z = X.microphone) == null ? void 0 : z.publishOptions) ?? {}
        ) : Promise.resolve()
      ]), await C(N), K && await y.waitUntilConnected(N), N == null || N.removeEventListener("abort", _);
    },
    [a, E, I, C, y.waitUntilConnected]
  ), q = r.useCallback(async () => {
    await a.disconnect();
  }, [a]), B = r.useCallback(async () => {
    const P = await I();
    await a.prepareConnection(P.serverUrl, P.participantToken);
  }, [I, a]);
  return r.useEffect(
    () => {
      B().catch((P) => {
        console.warn("WARNING: Room.prepareConnection failed:", P);
      });
    },
    [
      /* note: no prepareConnection here, this effect should only ever run once! */
    ]
  ), r.useMemo(
    () => ({
      ...h,
      waitUntilConnected: C,
      waitUntilDisconnected: E,
      prepareConnection: B,
      start: U,
      end: q
    }),
    [h, C, E, B, U, q]
  );
}
function is(e, n, t, s) {
  const o = r.useMemo(() => () => {
  }, []), c = r.useCallback(t ?? o, s ?? []), a = s ? c : t, i = r.useMemo(() => e ? "internal" in e ? e.internal.emitter : e : null, [e]);
  r.useEffect(() => {
    if (!(!i || !a))
      return i.on(n, a), () => {
        i.off(n, a);
      };
  }, [i, n, a]);
}
var gn = /* @__PURE__ */ ((e) => (e.MessageReceived = "messageReceived", e))(gn || {});
function us(e) {
  const { room: n } = Rt(e), t = r.useMemo(
    () => new pe.EventEmitter(),
    []
  ), s = Oe(e), o = an({ room: n }), c = r.useMemo(() => ({ room: n }), [n]), a = Qt(c), i = r.useMemo(() => o.map((p) => {
    var g, M, T;
    switch (p.participantInfo.identity) {
      case n.localParticipant.identity:
        return {
          type: "userTranscript",
          message: p.text,
          id: p.streamInfo.id,
          timestamp: p.streamInfo.timestamp,
          from: n.localParticipant
        };
      case ((g = s.internal.agentParticipant) == null ? void 0 : g.identity):
      case ((M = s.internal.workerParticipant) == null ? void 0 : M.identity):
        return {
          type: "agentTranscript",
          message: p.text,
          id: p.streamInfo.id,
          timestamp: p.streamInfo.timestamp,
          from: ((T = s.internal.agentParticipant) == null ? void 0 : T.identity) === p.participantInfo.identity ? s.internal.agentParticipant : s.internal.workerParticipant
        };
      default:
        return {
          type: "agentTranscript",
          message: p.text,
          id: p.streamInfo.id,
          timestamp: p.streamInfo.timestamp,
          from: Array.from(n.remoteParticipants.values()).find(
            (L) => L.identity === p.participantInfo.identity
          )
        };
    }
  }), [o, n]), d = r.useMemo(() => [...i, ...a.chatMessages], [i, a.chatMessages]), l = r.useRef(/* @__PURE__ */ new Map()), b = r.useMemo(() => {
    const p = /* @__PURE__ */ new Date();
    for (const g of d)
      l.current.has(g.id) || l.current.set(g.id, p);
    return d.sort((g, M) => {
      const T = l.current.get(g.id), L = l.current.get(M.id);
      return typeof T > "u" || typeof L > "u" ? 0 : T.getTime() - L.getTime();
    });
  }, [d]), u = r.useRef(/* @__PURE__ */ new Set());
  return r.useEffect(() => {
    for (const p of b)
      u.current.has(p.id) || (u.current.add(p.id), t.emit("messageReceived", p));
  }, [b]), r.useMemo(
    () => ({
      messages: b,
      send: a.send,
      isSending: a.isSending,
      internal: { emitter: t }
    }),
    [b, a.send, a.isSending]
  );
}
export {
  on as $,
  On as A,
  Hn as B,
  De as C,
  kn as D,
  Ln as E,
  qt as F,
  ve as G,
  Bt as H,
  Fn as I,
  xn as J,
  zt as K,
  Vn as L,
  me as M,
  Bn as N,
  Wt as O,
  Jn as P,
  Yn as Q,
  dn as R,
  Oe as S,
  es as T,
  ns as U,
  se as V,
  sn as W,
  rs as X,
  rn as Y,
  ss as Z,
  os as _,
  ee as a,
  an as a0,
  as as a1,
  mn as a2,
  cs as a3,
  is as a4,
  gn as a5,
  us as a6,
  Gn as b,
  An as c,
  Rn as d,
  In as e,
  jn as f,
  zn as g,
  Qn as h,
  Pn as i,
  A as j,
  $n as k,
  Un as l,
  Zn as m,
  Dn as n,
  _n as o,
  Wn as p,
  Vt as q,
  jt as r,
  ts as s,
  Kn as t,
  wn as u,
  qn as v,
  Qt as w,
  Xn as x,
  Nn as y,
  Tn as z
};
//# sourceMappingURL=hooks-CA8cirWq.mjs.map
